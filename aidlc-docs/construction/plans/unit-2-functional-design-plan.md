# Unit 2 Functional Design Plan - Customer Order Domain

## Overview

**Unit**: Unit 2 - Customer Order Domain  
**Purpose**: 고객의 주문 프로세스 관리  
**Bounded Context**: Customer Order Management

---

## Context

### Unit Responsibilities
- 메뉴 조회 및 탐색
- 장바구니 관리
- 주문 생성 및 조회
- 고객 UI 제공

### Assigned User Stories
- US-C-001: 테이블 태블릿 자동 로그인
- US-C-002: 메뉴 카테고리별 조회
- US-C-003: 장바구니에 메뉴 추가
- US-C-004: 장바구니 수량 조절
- US-C-005: 주문 생성
- US-C-006: 주문 내역 조회
- US-C-007: 주문 실패 처리
- US-C-008: 빈 장바구니 주문 방지

### Dependencies
- Unit 1 (Shared Foundation): 엔티티 (Menu, Order, OrderItem, Table), 인증, 데이터베이스, Repository

---

## Design Questions

다음 질문들에 답변하여 Unit 2의 Functional Design 방향을 결정해주세요.

### Q1: 메뉴 조회 필터링 전략

메뉴 조회 시 어떤 필터링 전략을 사용하시겠습니까?

**A)** 카테고리만 (Level 1 + Level 2)
- 장점: 단순함, 빠른 구현
- 단점: 검색 기능 없음

**B)** 카테고리 + 검색 (메뉴명)
- 장점: 사용자 편의성 향상
- 단점: 검색 인덱스 필요

**C)** 카테고리 + 검색 + 가격 범위 필터
- 장점: 고급 필터링
- 단점: 복잡도 증가

**D)** 카테고리 + 검색 + 가격 범위 + 판매 가능 여부
- 장점: 완전한 필터링
- 단점: 높은 복잡도

[Answer]: A

---

### Q2: 장바구니 데이터 구조

장바구니 데이터를 어떻게 구조화하시겠습니까?

**A)** 단순 배열 (메뉴 ID + 수량만)
- 장점: 단순함
- 단점: 옵션 정보 없음

**B)** 메뉴 정보 포함 (메뉴 ID + 메뉴 정보 스냅샷 + 수량)
- 장점: 메뉴 정보 즉시 표시 가능
- 단점: 데이터 중복

**C)** 메뉴 정보 + 선택된 옵션 포함
- 장점: 완전한 주문 정보
- 단점: 복잡한 구조

**D)** 메뉴 정보 + 옵션 + 고유 키 (같은 메뉴 다른 옵션 구분)
- 장점: 정확한 장바구니 관리
- 단점: 가장 복잡함

[Answer]: C

---

### Q3: 장바구니 중복 항목 처리

같은 메뉴를 여러 번 추가할 때 어떻게 처리하시겠습니까?

**A)** 수량 증가 (같은 메뉴는 하나의 항목으로 통합)
- 장점: 장바구니 간결
- 단점: 옵션이 다른 경우 처리 어려움

**B)** 별도 항목 추가 (같은 메뉴도 별도 라인으로)
- 장점: 단순한 로직
- 단점: 장바구니가 길어질 수 있음

**C)** 옵션 동일 시 수량 증가, 옵션 다르면 별도 항목
- 장점: 합리적인 처리
- 단점: 옵션 비교 로직 필요

**D)** 사용자에게 선택 요청 (통합 또는 별도 추가)
- 장점: 사용자 제어
- 단점: 추가 UI 필요

[Answer]: C

---

### Q4: 주문 생성 유효성 검증

주문 생성 시 어떤 유효성 검증을 수행하시겠습니까?

**A)** 최소 검증 (장바구니 비어있지 않음만)
- 장점: 빠른 주문
- 단점: 에러 가능성

**B)** 기본 검증 (장바구니 + 메뉴 판매 가능 여부)
- 장점: 기본적인 안전성
- 단점: 메뉴 조회 필요

**C)** 상세 검증 (장바구니 + 메뉴 판매 가능 + 가격 일치)
- 장점: 높은 안전성
- 단점: 추가 검증 시간

**D)** 완전 검증 (장바구니 + 메뉴 판매 가능 + 가격 일치 + 옵션 유효성)
- 장점: 최고 안전성
- 단점: 복잡한 검증 로직

[Answer]: A

---

### Q5: 주문 내역 조회 범위

주문 내역 조회 시 어떤 범위의 주문을 표시하시겠습니까?

**A)** 현재 세션만 (테이블 세션 시작 이후)
- 장점: 관련 주문만 표시
- 단점: 과거 내역 없음

**B)** 현재 세션 + 오늘 주문
- 장점: 당일 주문 확인 가능
- 단점: 세션 개념과 혼재

**C)** 현재 세션 + 최근 N개 주문
- 장점: 최근 주문 확인 가능
- 단점: 세션 경계 모호

**D)** 현재 세션만 (명확한 경계)
- 장점: 명확한 범위
- 단점: 제한적

[Answer]: A

---

### Q6: 주문 상태 실시간 업데이트

고객 화면에서 주문 상태를 실시간으로 업데이트하시겠습니까?

**A)** 실시간 업데이트 없음 (새로고침 필요)
- 장점: 단순한 구현
- 단점: 사용자 경험 저하

**B)** 폴링 방식 (주기적으로 서버 조회)
- 장점: 구현 간단
- 단점: 서버 부하, 지연

**C)** SSE 방식 (서버에서 푸시)
- 장점: 실시간, 효율적
- 단점: SSE 구현 필요

**D)** WebSocket 방식 (양방향 통신)
- 장점: 완전한 실시간
- 단점: 복잡한 구현

[Answer]: C

---

### Q7: 메뉴 옵션 선택 UI

메뉴 옵션 선택을 어떻게 처리하시겠습니까?

**A)** 옵션 없이 기본 메뉴만 주문
- 장점: 단순함
- 단점: 옵션 기능 미사용

**B)** 장바구니 추가 시 옵션 선택 모달
- 장점: 명확한 옵션 선택
- 단점: 추가 클릭 필요

**C)** 메뉴 상세 화면에서 옵션 선택 후 추가
- 장점: 상세 정보 확인 가능
- 단점: 추가 화면 필요

**D)** 장바구니에서 옵션 수정 가능
- 장점: 유연한 수정
- 단점: 복잡한 UI

[Answer]: B

---

### Q8: 주문 번호 생성 전략

주문 번호를 어떻게 생성하시겠습니까?

**A)** 매장별 순차 번호 (001, 002, 003, ...)
- 장점: 사람이 읽기 쉬움
- 단점: 동시성 처리 필요

**B)** 날짜 + 순차 번호 (20260209-001)
- 장점: 날짜 정보 포함
- 단점: 긴 번호

**C)** UUID (랜덤 고유 식별자)
- 장점: 충돌 없음
- 단점: 사람이 읽기 어려움

**D)** 테이블 번호 + 순차 번호 (T01-001)
- 장점: 테이블 정보 포함
- 단점: 테이블별 관리 필요

[Answer]: D

---

### Q9: 장바구니 영속성 전략

장바구니 데이터를 어떻게 저장하시겠습니까?

**A)** SessionStorage만 (세션 종료 시 삭제)
- 장점: 단순함
- 단점: 브라우저 종료 시 손실

**B)** LocalStorage (영구 저장)
- 장점: 데이터 유지
- 단점: 세션 개념과 맞지 않음

**C)** SessionStorage + 서버 백업
- 장점: 안전성
- 단점: 서버 저장 필요

**D)** 서버 세션만 (클라이언트 저장 없음)
- 장점: 중앙 관리
- 단점: 네트워크 의존

[Answer]: A

---

### Q10: 에러 처리 전략

주문 프로세스에서 에러를 어떻게 처리하시겠습니까?

**A)** 기본 에러 메시지만 표시
- 장점: 단순함
- 단점: 사용자 혼란

**B)** 에러 타입별 메시지 (네트워크, 서버, 유효성)
- 장점: 명확한 피드백
- 단점: 에러 분류 필요

**C)** 에러 메시지 + 재시도 버튼
- 장점: 사용자 편의성
- 단점: 재시도 로직 필요

**D)** 에러 메시지 + 재시도 + 로깅
- 장점: 완전한 에러 처리
- 단점: 복잡한 구현

[Answer]: A

---

## Completion Checklist

- [x] 모든 질문에 답변 완료
- [x] 답변의 일관성 확인
- [x] 모호한 답변 없음
- [x] 계획 승인 준비

---

**문서 버전**: 1.0  
**작성일**: 2026-02-09  
**상태**: 완료
